import java.math.*;
import java.util.*;
import java.util.stream.*;

/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
class Library {

    public static List<long[]> powerSetSub(long[] values, int k) {
        BigInteger startKB = BigInteger.ONE.shiftLeft(k).subtract(BigInteger.ONE);

        BigInteger x = startKB;
        System.out.println(startKB);
        BigInteger kFound = BigInteger.ZERO;
        BigInteger maxK = (factorial(values.length).divide(factorial(k).multiply(factorial(values.length - k))));

        List<long[]> powersSets = new ArrayList<>(10_000);

        BigInteger[] powerSetBits = new BigInteger[values.length];
        for (int i = 0 ; i < values.length; i++) {
            powerSetBits[i] = BigInteger.ONE.shiftLeft(i);
        }

       // System.out.println(maxK);
        while (kFound.compareTo(maxK) != 0) {
            long[] sets = new long[k];
            int kIdx = 0;
            for (int j = 0; j < values.length; j++) {
                if (powerSetBits[j].compareTo(x) > 0) {
                    break;
                }
                if (x.and(powerSetBits[j]).compareTo(BigInteger.ZERO) > 0)  {
                    sets[kIdx] = values[j];
                    kIdx++;
                }
            }

           kFound = kFound.add(BigInteger.ONE);
//            BigInteger y = x.and(x.negate());
//            BigInteger c = x.add(y);
//            x = (x.xor(c)).shiftRight(2).divide(y).or(c);

//            unsigned int t = (v | (v - 1)) + 1;
          // w = t | ((((t & -t) / (v & -v)) >> 1) - 1);

            BigInteger t = x.or(x.subtract(BigInteger.ONE)).add(BigInteger.ONE);
            x = t.or(t.and(t.negate()).divide(x.and(x.negate())).shiftRight(1).subtract(BigInteger.ONE));

            powersSets.add(sets);
        }

//        Set<List<Long>> powersSets = new HashSet<>(100_000);
//
//        BigInteger max = new BigInteger("2").pow(values.length);
//
//        BigInteger kFound = BigInteger.ZERO;
//        BigInteger maxK = (factorial(values.length).divide(factorial(k).multiply(factorial(values.length - k))));
//        System.out.println(maxK);
//        for (BigInteger i = BigInteger.ZERO; i.compareTo(max) < 0; i = i.add(BigInteger.ONE)) {
//            List<Long> sets = new ArrayList<>();
//            for (int j = 0; j < values.length; j++) {
//                BigInteger shiftJ = BigInteger.ONE.shiftLeft(j);
//                if (i.and(shiftJ).compareTo(BigInteger.ZERO) > 0)  {
//                    sets.add(values[j]);
//                }
//            }
//
//            if (sets.size() == k) {
//                kFound = kFound.add(BigInteger.ONE);
//                powersSets.add(sets);
//
//                if (kFound == maxK) {
//                    return new ArrayList<>(powersSets);
//                }
//            }
//        }

        return powersSets;
    }

    public static BigInteger factorial(long n) {
        BigInteger result = BigInteger.ONE;
        for (long i = 1; i <= n; i++) {
            result = result.multiply(BigInteger.valueOf(i));
        }
        return result;
    }

    public static long[] powerSetWithMaxValue2(long[] values, int sequenceLength) {
        List<long[]> powerSets = powerSetSub(values, sequenceLength);

        long max = 0;
        long maxCount = 0;

        for (int i = 0; i < powerSets.size(); i++) {
            long bitwiseAndSum = Arrays.stream(powerSets.get(i))
                    .reduce(Long.MAX_VALUE, (x, y) -> x & y);

            if (bitwiseAndSum > max) {
                max = bitwiseAndSum;
                maxCount = 1;
            }
            else if (bitwiseAndSum == max) {
                maxCount++;
            }
        }

        long modulus =  maxCount % (1000000007L);

        return new long[] {max, modulus};
    }


    public static long[][] powerSet(long[] values) {
        int powerSet = (int) Math.pow(2, values.length);

        long[][] powersSets = new long[powerSet][];

        for (int i = 0; i < powerSet; i++) {
            List<Long> sets = new ArrayList<>();
            for (int j = 0; j < values.length; j++) {
                if ((i & ( 1 << j)) > 0)  {
                    sets.add(values[j]);
                }
            }

            powersSets[i] = sets.stream().mapToLong(Long::longValue).toArray();
        }
        return powersSets;
    }

    public static long[] powerSetWithMaxValue(long[] values, int sequenceLength) {
        long[][] powerSets = powerSet(values, sequenceLength);

        long max = 0;
        long maxCount = 0;

        for (int i = 0; i < powerSets.length; i++) {
            long bitwiseAndSum = Arrays.stream(powerSets[i])
                    .reduce(powerSets[i][0], (x, y) -> x & y);

            if (bitwiseAndSum > max) {
                max = bitwiseAndSum;
                maxCount = 1;
            }
            else if (bitwiseAndSum == max) {
                maxCount++;
            }
        }

        long modulus =  maxCount % (1_000_000_007);

        return new long[] {max, modulus};
    }

    public static long[][] powerSet(long[] values, int sequenceLength) {
       long[][] powerSets = powerSet(values);

       List<long[]> valuesWithLength = new ArrayList<>();
       for (int i = 0; i < powerSets.length; i++) {
           if (powerSets[i].length == sequenceLength) {
               valuesWithLength.add(powerSets[i]);
           }
       }

       long[][] newPowerSets = new long[valuesWithLength.size()][];
       for (int i = 0; i < newPowerSets.length; i++) {
           newPowerSets[i] = valuesWithLength.get(i);
       }

       return newPowerSets;
    }

    public static int getZigzag(int[] values) {
        List<Integer> valuesList = new LinkedList(Arrays.stream(values).boxed().collect(Collectors.toList()));
        List<Integer> stack = new LinkedList<>();

        int moves = 0;

        for (int i = 0; i < valuesList.size(); i++) {
            stack.add(valuesList.get(i));

            if (stack.size() == 3) {
                if (stack.get(0) < stack.get(1) && stack.get(1) < stack.get(2)
                    || stack.get(0) > stack.get(1) && stack.get(1) > stack.get(2)) {
                    moves++;
                    valuesList.remove(i - 1);
                    i = -1;
                    stack.clear();
                }
                else {
                    stack.remove(0);
                }
            }
        }

        return moves;
    }

    public static int getPoints(int month1, int month2, int month3) {
        return toPoints(month1) + toPoints(month2) + toPoints(month3);
    }

    private static int toPoints(int month1) {
        int amount = month1 * 10;
        return amount > 100 ? 100 : amount;
    }
}
