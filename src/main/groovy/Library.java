import java.math.*;
import java.util.*;
import java.util.stream.*;

/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
class Library {

    Map<BigInteger, BigInteger> value = new HashMap<>();

    public static List<Long> powerSetSub(long[] values, int k) {
        List<Long> valuesList = Arrays.stream(values).boxed().collect(Collectors.toList());

        for (int j = 63; j >= 0; j--) {
            List<Long> valuesWithKBitSet = new ArrayList<>();

            for (int i = 0; i < valuesList.size(); i++) {
                if ((valuesList.get(i) & (1L << (long) j)) > 0) {
                    valuesWithKBitSet.add(valuesList.get(i));
                }
            }

            if (valuesWithKBitSet.size() >= k) {
                valuesList = valuesWithKBitSet;
            }
        }

        return valuesList;
    }

    static long convert (BigInteger value, BigInteger base) {

        if (value.divide(base).equals(BigInteger.ZERO)) {
            return value.longValue();
        }

        StringBuilder stringBuilder = new StringBuilder();

        while (!value.equals(BigInteger.ZERO)) {
            BigInteger[] values = value.divideAndRemainder(base);
            value = values[0];
            BigInteger digit = values[1];
            stringBuilder.append(digit.toString());
        }

        return Long.parseLong(stringBuilder.reverse().toString());
    }

    public static BigInteger factorial(int k) {
//        double ln = 0;
//        for (int i = 2; i<= k; i++) {
//            ln+= Math.log(i);
//        }
//
//        return BigInteger.valueOf((long) ln);
//
     //   Euler's inverse modular arithmetic.
//        BigInteger factorial = BigInteger.ONE;
//        for (int i = 1; i<= k; i++) {
//            factorial = factorial.multiply(BigInteger.valueOf(i));
//        }
//
//        return factorial;

        return split(BigInteger.valueOf(k), BigInteger.ZERO);
    }

    public static BigInteger split(BigInteger a, BigInteger b) {
        BigInteger d = a.subtract(b);

        if (d.compareTo(BigInteger.ZERO) < 0) {
            return BigInteger.ZERO;
        }
        else if (d.equals(BigInteger.ZERO)) {
            return BigInteger.ONE;
        }
        else if (d.equals(BigInteger.ONE)) {
            return a;
        }
        else if (d.equals(BigInteger.valueOf(2))) {
            return a.multiply(a.subtract(BigInteger.ONE));
        }
        else if (d.equals(BigInteger.valueOf(3))) {
            return a.multiply(a.subtract(BigInteger.ONE)).multiply(a.subtract(BigInteger.valueOf(2)));
        }
        else {
            BigInteger m = a.add(b).divide(BigInteger.valueOf(2));
            return split(a, m).multiply(split(m, b));
        }
    }


    public static long[] powerSetWithMaxValue2(long[] values, int sequenceLength) {
        List<Long> maximalK = powerSetSub(values, sequenceLength);
        long bitwiseAndSum = maximalK.get(0);
        for(int i=1; i<sequenceLength; i++)
        {
            bitwiseAndSum = (bitwiseAndSum & maximalK.get(i));
        }


        BigInteger nFactorial = factorial(maximalK.size());
        BigInteger kFactorial = factorial(sequenceLength);

        BigInteger divisor = kFactorial.multiply(
                              factorial(maximalK.size() -sequenceLength));
        BigInteger divide = nFactorial.divide(divisor);

        BigInteger maxCount = (maximalK.size() == sequenceLength) ? BigInteger.ONE : divide;


        //List<Long> maximalK = powerSetSub(values, sequenceLength);
       // long bitwiseAndSum = maximalK
//                .stream()
//                .reduce(Long.MAX_VALUE, (x, y) -> x & y);

//        int n = maximalK.size();
//        int kElements
//
//        long n = convert(BigInteger.valueOf((long) maximalK.size()), BigInteger.valueOf(1000000007L)));
//        long k = (convert(BigInteger.valueOf((long) sequenceLength), BigInteger.valueOf(1000000007L)));


        long modulus =  maxCount.mod(BigInteger.valueOf(1000000007L)).longValue();

        return new long[] {bitwiseAndSum, modulus};
    }


    public static long[][] powerSet(long[] values) {
        int powerSet = (int) Math.pow(2, values.length);

        long[][] powersSets = new long[powerSet][];

        for (int i = 0; i < powerSet; i++) {
            List<Long> sets = new ArrayList<>();
            for (int j = 0; j < values.length; j++) {
                if ((i & ( 1 << j)) > 0)  {
                    sets.add(values[j]);
                }
            }

            powersSets[i] = sets.stream().mapToLong(Long::longValue).toArray();
        }
        return powersSets;
    }

    public static long[] powerSetWithMaxValue(long[] values, int sequenceLength) {
        long[][] powerSets = powerSet(values, sequenceLength);

        long max = 0;
        long maxCount = 0;

        for (int i = 0; i < powerSets.length; i++) {
            long bitwiseAndSum = Arrays.stream(powerSets[i])
                    .reduce(powerSets[i][0], (x, y) -> x & y);

            if (bitwiseAndSum > max) {
                max = bitwiseAndSum;
                maxCount = 1;
            }
            else if (bitwiseAndSum == max) {
                maxCount++;
            }
        }

        long modulus =  maxCount % (1_000_000_007);

        return new long[] {max, modulus};
    }

    public static long[][] powerSet(long[] values, int sequenceLength) {
       long[][] powerSets = powerSet(values);

       List<long[]> valuesWithLength = new ArrayList<>();
       for (int i = 0; i < powerSets.length; i++) {
           if (powerSets[i].length == sequenceLength) {
               valuesWithLength.add(powerSets[i]);
           }
       }

       long[][] newPowerSets = new long[valuesWithLength.size()][];
       for (int i = 0; i < newPowerSets.length; i++) {
           newPowerSets[i] = valuesWithLength.get(i);
       }

       return newPowerSets;
    }

    public static int getZigzag(int[] values) {
        List<Integer> valuesList = new LinkedList(Arrays.stream(values).boxed().collect(Collectors.toList()));
        List<Integer> stack = new LinkedList<>();

        int moves = 0;

        for (int i = 0; i < valuesList.size(); i++) {
            stack.add(valuesList.get(i));

            if (stack.size() == 3) {
                if (stack.get(0) < stack.get(1) && stack.get(1) < stack.get(2)
                    || stack.get(0) > stack.get(1) && stack.get(1) > stack.get(2)) {
                    moves++;
                    valuesList.remove(i - 1);
                    i = -1;
                    stack.clear();
                }
                else {
                    stack.remove(0);
                }
            }
        }

        return moves;
    }

    public static int getPoints(int month1, int month2, int month3) {
        return toPoints(month1) + toPoints(month2) + toPoints(month3);
    }

    private static int toPoints(int month1) {
        int amount = month1 * 10;
        return amount > 100 ? 100 : amount;
    }
}
